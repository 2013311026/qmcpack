#! /usr/bin/env python

import os
import sys
from subprocess import Popen,PIPE

#=======#
# setup #
#=======#

# define usage
usage = 'usage: "install path/to/install/directory"'

# find paths to install script and source directory
installer  = os.path.realpath(__file__)
source_dir = os.path.dirname(installer)
lib_dir    = os.path.join(source_dir,'lib')
bin_dir    = os.path.join(source_dir,'bin')

# function to report errors
def error(msg):
    print 'install error: '+msg
    sys.exit(1)
#end def error

# function to execute shell commands
def execute(command):
    process = Popen(command,shell=True,stdout=PIPE,stderr=PIPE,close_fds=True)
    out,err = process.communicate()
    if process.returncode!=0:
        error('problem encountered, see output below\nout: {0}\nerr: {1}'.format(out,err))
    #end if
    return out,err
#end def execute

#================#
# main execution #
#================#

# check user input
args = sys.argv[1:]
if len(args)==0:
    install_dir = source_dir
elif len(args)>1:
    error('install only takes one argument\nyou provided {0}\n{1}'.format(args,usage))
else:
    install_dir = os.path.realpath(args[0])
#end if

# copy binaries to install dir
if install_dir!=source_dir:
    # create install directory, if needed
    install_dir = args[0]
    if not os.path.exists(install_dir):
        os.makedirs(install_dir)
    #end if

    # copy binaries
    execute('cp {0}/bin/* {1}'.format(source_dir,install_dir))

    # update bin directory for install
    bin_dir = install_dir
#end if

# install library (add lib path to PYTHONPATH)

# determine shell
def get_shell():
    shells = 'bash tcsh csh ksh zsh'.split()
    texts = [
        os.readlink('/proc/%d/exe' % os.getppid()),
        os.environ['SHELL']
        ]
    for text in texts: 
        for shell in shells:
            if shell in text:
                return shell
            #end if
        #end for
    #end for
    error('user shell could not be identified')
#end def get_shell
shell = get_shell()
shell_rc_files = dict(
    sh   = ['.profile'],
    ksh  = ['.kshrc','.profile'],
    csh  = ['.cshrc','.login'],
    tcsh = ['.tcshrc','.cshrc','.login'],
    bash = ['.bashrc','.bash_login','.bash_profile','.profile'],
    zsh  = ['.zshrc','.zlogin','.zprofile','.zshenv'],
    )
if shell not in shell_rc_files:
    error('user shell "{0}" is not recognized'.format(shell))
#end if

# find config (rc) file for shell
rc_files = shell_rc_files[shell]
home = os.path.expanduser('~') # this is cross-platform
rc_file = None
search_paths = []
for rc in rc_files:
    rc_filepath = os.path.join(home,rc)
    search_paths.append(rc_filepath)
    if os.path.exists(rc_filepath):
        rc_file = rc_filepath
        break
    #end if
#end for
if rc_file is None:
    error('could not identify unix config (rc) file for shell "{0}"\nlocations searched: {1}'.format(shell,search_paths))
#end if

# get format for setting env variables in shell
set_env_formats = dict(
    ksh  = 'export {0}={1}\n',
    csh  = 'setenv {0} {1}\n',
    tcsh = 'setenv {0} {1}\n',
    bash = 'export {0}={1}\n',
    zsh  = 'export {0}={1}\n',
    )
set_env_fmt = set_env_formats[shell]

# add lib path to PYTHONPATH in config file
header = '### added by Nexus 1.6.0 installer ###'
footer = '### end Nexus additions ###'
execute('cp {0} {0}-nexus.bak'.format(rc_file))
f = open(rc_file,'r')
rc_contents = f.read()
f.close()
if header in rc_contents and footer in rc_contents:
    header_loc = rc_contents.find(header)
    footer_loc = rc_contents.find(footer)
    before_header = rc_contents[:header_loc]
    after_footer  = rc_contents[footer_loc+len(footer):]
    rc_contents = before_header + after_footer
#end if
rc_contents = rc_contents.rstrip()+'\n\n\n'
rc_contents += header+'\n'
rc_contents += set_env_fmt.format('PATH',bin_dir+':$PATH')
rc_contents += set_env_fmt.format('PYTHONPATH',lib_dir+':$PYTHONPATH')
rc_contents += footer+'\n'
f = open(rc_file,'w')
f.write(rc_contents)
f.close()
