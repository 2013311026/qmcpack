\chapter{Additional Tools}
\label{chap:additional_tools}
QMCPACK provides a set of lightweight executables that address certain
common problems in QMC workflow and analysis.  These range from conversion utilities between 
different file formats and QMCPACK (e.g. ppconvert and convert4qmc),  
(extract-eshdf-kvectors), to post-processing utilities (trace-density and qmcfinitesize), and to many others.  In this chapter, we cover the use cases, syntax, and features of all additional tools provided with QMCPACK.  

\section{Initialization Tools}
  \subsection{getSupercell}

\section{Post-Processing}
  \subsection{qmca}
    qmca is a versatile tool to analyze and plot the raw data from QMCPACK *.scalar.dat files.
    It is a python executable and part of the Nexus suite of tools.  It can be found in 
    \texttt{trunk/nexus/executables}. 
  \subsection{qmcfit}
  \subsection{qmcfinitesize}
    qmcfinitesize is a utility to compute many-body finite-size corrections to the energy.  It
    is a C++ executable that is built alongside the qmcpack executable.  It can be found in 
    \texttt{trunk/build/bin}
  \subsection{trace-density}

\section{Converters} 
\input{convert4qmc}    
  \subsection{wfconvert}
    wfconvert allows the conversion of wavefunction from another code into a format supported by QMCPACK.
    Currently most its important features are available within QMCPACK and there is no need to use it anymore.
    Converting wavefunctions from LAPW, nonuniform b-splines, wannier functions has not been transferred.
  \subsection{pw2qmcpack.x}
    pw2qmcpack.x is an executable that converts PWSCF wavefunctions to QMCPACK readable 
    HDF5 format.  This utility is built alongside the Quantum Espresso post-processing utilities.
    This utility is written in Fortran90, and is distributed as a patch of the Quantum Espresso 
    source code.  The patch, as well as automated QE download and patch scripts, can be found in 
    \texttt{trunk/external\_codes/quantum\_espresso}.
  \subsection{ppconvert}
    ppconvert is a utility to convert pseudopotentials between different commonly used formats.
    It is a stand alone C++ executable that is not built by default but accessible via adding
    \texttt{-DBUILD\_PPCONVERT=1} to cmake and then typing \texttt{make ppconvert}.
    Currently it converts CASINO, FHI, UPF (generated by OPIUM), BFD, GAMESS formats to several formats
    including XML (QMCPACK) and UPF (Quantum ESPRESSO). See all the formats via \texttt{ppconvert -h}.
    For the output formats requiring Kleinman-Bylander projectors, the atom will be solved with DFT
    if the projects are not provided by the input formats.
    This requires providing reference states and sometimes needs extra tuning for heavy elements.
    To avoid ghost states, the local channel can be changed via the \texttt{--local\_channel} option.
    To make the self-consisnent calculation converge, the density mixing parameter may need to be reduced
    via the \texttt{--density\_mix} option.

    Note that the reference state should include only the valence electrons.
    One reference state should be included for each channel in the pseudopotential.
    For example, for a sodium atom with a neon core, the reference state would be ``1s(1)''.
    \texttt{--s\_ref} needs to include a 1s state, \texttt{--p\_ref} needs to include a 2p state,
    \texttt{--d\_ref} needs to include a 3d state, etc. If not specified, a corresponding state with zero occupation is added.
    If the reference state is chosen as the neon core, setting empty reference states ``'' is techinically correct.
    In practice, reasonable reference states should be picked with care.
    For pseudopotentials with semi-core electrons in the valence, the reference state can be long.
    For example, Ti pseudopotential has 12 valence electrons. When using the neutral atom state,
    \texttt{--s\_ref}, \texttt{--p\_ref}, \texttt{--d\_ref} are all set as ``1s(2)2p(6)2s(2)3d(2)''.
    When using an ionized state, the three reference states are all set as ``1s(2)2p(6)2s(2)'' or ``1s(2)2p(6)2s(2)3d(0)''.
    Unfortunately, if the generated UPF file is used in Quantum ESPRESSO, the calculation is wrong due to ``ghost'' states
    which can be removed by setting \texttt{--local\_channel 1} which chooses the p channel as the local channel instead of d.
    For this reason, validation of UPF pseudopotentials is always required from the third row.
\input{pseudopotentials}
\section{Miscellaneous}
  \subsection{extract-eshdf-kvectors}
    

