--Things have been reorganized (for the better) regarding jastrow builders
--For now, decide to ignore the possibility for a spin dependent one-body jastrow function (no use case has yet been found).  Probably should revisit this later.
--I'm looking to add one and two body analytic jastrow factors.  First for the one-body, I would take over the pade, pade2, pade2secondorder etc and replace them with the proper versions,

-- Next consideration is how to handle the correlation sub-tag.  It makes sense that this currently describes what species we are having correlations between and whether there is a cusp (and if so what magnitude).  The problem is that bspline jastrows use this to specify how many knots will be used.



For Pade First Order, example blocks that should work:
<jastrow name="J1" type="One-Body" function="pade1" print="yes" source="i">
  <correlation elementType="C" cusp="0.0">
     <parameter id="CB" name="B" optimize="yes"> 1.0 </parameter>
  </correlation>
</jastrow>

!<jastrow name="J1" type="One-Body" function="pade1" print="yes" source="i">
!  <correlation speciesA="C" speciesB="u" cusp="0.0">
!     <parameter id="CuB" name="B" optimize="yes"> 1.0 </parameter>
!  </correlation>
!  <correlation speciesA="C" speciesB="d" cusp="0.0">
!     <parameter id="CdB" name="B" optimize="yes"> 0.5 </parameter>
!  </correlation>
!</jastrow>

<jastrow name="J2" type="Two-Body" function="pade1" print="yes">
  <correlation speciesA="u" speciesB="u">
     <parameter id="uuB" name="B" optimize="yes"> 1.0 </parameter>
  </correlation>
  <correlation speciesA="u" speciesB="d">
     <parameter id="udB" name="B" optimize="yes"> 1.0 </parameter>
  </correlation>
</jastrow>

First Order
-- \f u(r) = \frac{a*r}{1+b*r} - a/b\f]
-- cusp (derivative at r->0) is a

For Higher order derivatives use sympy:
from sympy import *
a, b, r = symbols('a b r')
f = a*r / (1+ b*r)
1st Deriv wrt r: simplify(diff(f,r))
2nd Deriv wrt r: simplify(diff(f,r,2))
3rd Deriv wrt r: simplify(diff(f,r,2))

# Not used as a is the cusp and should not be optimized
#1st Deriv wrt a: simplify(diff(f,a))
#1st Deriv wrt a, followed by deriv wrt r: simplify(diff(diff(f,a),r))
#1st Deriv wrt a, followed by 2nd deriv wrt r: simplify(diff(diff(f,a),r,2))

1st Deriv wrt b, simplify(diff(f,b))
1st Deriv wrt b, followed by deriv wrt r: simplify(diff(diff(f,b),r))
1st Deriv wrt b, followed by 2nd deriv wrt r: simplify(diff(diff(f,b),r,2))


For Pade Second Order, example blocks that should work:
<jastrow name="J1" type="One-Body" function="pade2" print="yes" source="i">
  <correlation elementType="C" cusp="0.0">
     <parameter id="CB" name="B" optimize="yes"> 1.0 </parameter>
     <parameter id="CC" name="C" optimize="yes"> 1.0 </parameter>
     <parameter id="CD" name="D" optimize="yes"> 1.0 </parameter>
  </correlation>
</jastrow>

!<jastrow name="J1" type="One-Body" function="pade2" print="yes" source="i">
!  <correlation speciesA="C" speciesB="u" cusp="0.0">
!     <parameter id="CuB" name="B" optimize="yes"> 1.0 </parameter>
!     <parameter id="CuC" name="C" optimize="yes"> 1.0 </parameter>
!     <parameter id="CuD" name="D" optimize="yes"> 1.0 </parameter>
!  </correlation>
!  <correlation speciesA="C" speciesB="d" cusp="0.0">
!     <parameter id="CdB" name="B" optimize="yes"> 0.5 </parameter>
!     <parameter id="CdC" name="C" optimize="yes"> 0.5 </parameter>
!     <parameter id="CdD" name="D" optimize="yes"> 0.5 </parameter>
!  </correlation>
!</jastrow>

<jastrow name="J2" type="Two-Body" function="pade2" print="yes">
  <correlation speciesA="u" speciesB="u">
     <parameter id="uuB" name="B" optimize="yes"> 1.0 </parameter>
     <parameter id="uuC" name="C" optimize="yes"> 1.0 </parameter>
     <parameter id="uuD" name="D" optimize="yes"> 1.0 </parameter>
  </correlation>
  <correlation speciesA="u" speciesB="d">
     <parameter id="udB" name="B" optimize="yes"> 1.0 </parameter>
     <parameter id="udC" name="C" optimize="yes"> 1.0 </parameter>
     <parameter id="udD" name="D" optimize="yes"> 1.0 </parameter>
  </correlation>
</jastrow>

Second Order
\f[ u(r) = \frac{a*r+b*r^2}{1+c*r+d*r^2} \f]
cusp (derivative at r->0) is a


from sympy import *
a, b, c, d, r = symbols('a b c d r')
abr, a2br, cdr, c2dr, denom, combo = symbols('abr  a2br cdr  c2dr  denom combo')
f = (a*r+b*r*r) / (1+c*r+d*r*r)
1st Deriv wrt r: simplify(diff(f,r,1).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+d*r,cdr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br)
2nd Deriv wrt r: simplify(diff(f,r,2).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+d*r,cdr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br)
3rd Deriv wrt r: simplify(diff(f,r,3).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+d*r,cdr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br)

# Not used as a is the cusp and should not be optimized
#1st Deriv wrt a: simplify(diff(f,a)).subs(a+b*r,abr).subs(1+c*r+d*r**2,denom)
#1st Deriv wrt a, followed by deriv wrt r: simplify(diff(diff(f,a),r)).subs(a+b*r,abr).subs(1+c*r+d*r**2,denom).subs(c+2*d*r,c2dr)
#1st Deriv wrt a, followed by 2nd deriv wrt r: simplify(diff(diff(f,a),r,2)).subs(a+b*r,abr).subs(1+c*r+d*r**2,denom).subs(c+2*d*r,c2dr)

1st Deriv wrt b: simplify(diff(f,b).subs(1/(1+c*r+d*r**2),denom))
1st Deriv wrt b, followed by deriv wrt r: simplify(diff(diff(f,b),r,1).subs(1/(1+c*r+d*r**2),denom).subs(c+2*d*r,c2dr)).subs(c2dr*denom*r,combo)
1st Deriv wrt b, followed by 2nd deriv wrt r: implify(diff(diff(f,b),r,2).subs(1/(1+c*r+d*r**2),denom).subs(c+2*d*r,c2dr)).subs(c2dr*denom*r,combo)

1st Deriv wrt c: simplify(diff(f,c).subs(1/(1+c*r+d*r**2),denom).subs(a+b*r,abr))
1st Deriv wrt c, followed by deriv wrt r: simplify(diff(diff(f,c),r,1).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br).subs(c2dr*denom*r,combo)
1st Deriv wrt c, followed by 2nd deriv wrt r: simplify(diff(diff(f,c),r,2).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br).subs(c2dr*denom*r,combo)

1st Deriv wrt d: simplify(diff(f,d).subs(1/(1+c*r+d*r**2),denom).subs(a+b*r,abr))
1st Deriv wrt d, followed by deriv wrt r: simplify(diff(diff(f,d),r,1).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br).subs(c2dr*denom*r,combo)
1st Deriv wrt d, followed by 2nd deriv wrt r: simplify(diff(diff(f,d),r,2).subs(1/(1+c*r+d*r**2),denom)).subs(a+b*r,abr).subs(c+2*d*r,c2dr).subs(a+2*b*r,a2br).subs(c2dr*denom*r,combo)





Note that neither of these can have cutoffs, so they are really only appropriate for one open boundary conditions.  Also, the first order pade
cannot be configured to be cusp-less, so it is not really appropriate for one body jastrows in the case where we have a pseudopotential.





Also, will add a more flexible jastrow factor from Drummond, Towler and Needs, PRB 70, 235119 (2004)
\f[ u(x) = (r - L)^c Theta(L - r) (alpha_0 + [Gamma / (-L)^c + alpha_0 * c / L]*r + \sum(l=2,N) alpha_l * r^l)
  -- L is the cutoff-length (Parameter -- do not allow it to be optimize for now)
  -- c is the number of continuous derivatives (choose 2 or 3) (Parameter -- do not allow it to be optimized)
  -- Gamma is the cusp (so 1/2 for antiparellel spin electrons, 1/4 for parallel spin electrons and Z for all electron ions)

<jastrow name="J1" type="One-Body" function="casino04" print="yes" source="i">
  <correlation elementType="C" cusp="0.0" rcut="4.0" size="8" cont="3">
     <coefficients id="alphaC" type="Array" optimize="yes">  0 0 0 0 0 0 0 0 </coefficients>
  </correlation>
</jastrow>

!<jastrow name="J1" type="One-Body" function="casino04" print="yes" source="i">
!  <correlation speciesA="C" speciesB="u" cusp="0.0" rcut="4.0" size="8" cont="3">
!     <coefficients id="alphaCUp" type="Array" optimize="yes">  0 0 0 0 0 0 0 0 </coefficients>	
!  </correlation>
!  <correlation speciesA="C" speciesB="d" cusp="0.0" rcut="4.0" size="8" cont="3">
!     <coefficients id="alphaCDn" type="Array" optimize="yes">  0 0 0 0 0 0 0 0 </coefficients>
!  </correlation>
!</jastrow>

<jastrow name="J2" type="Two-Body" function="casino04" print="yes">
  <correlation speciesA="u" speciesB="u" rcut="4.0" size="8" cont="3">
     <parameter id="uu" type="Array" optimize="yes"> 0 0 0 0 0 0 0 0 </parameter>
  </correlation>
  <correlation speciesA="u" speciesB="d" rcut="4.0" size="8" cont="3">
     <parameter id="ud" type="Array" optimize="yes"> 0 0 0 0 0 0 0 0 </parameter>
  </correlation>
</jastrow>


from sympy import *
r, L, c, a0, a2, a3, a4, ser, dser, d2ser, d3ser, fac, rml = symbols('r L c a0 a2 a3 a4 ser dser d2ser d3ser fac rml')
f = (r-L)**c*(a0+(g/(-L)**c + a0*c/L)*r + a2*r**2 + a3*r**3 + a4*r**4)
r, L, c, a0, a2, a3, a4, a5, ser, dser, d2ser, d3ser, fac, rml, g = symbols('r L c a0 a2 a3 a4 a5 ser dser d2ser d3ser fac rml g')


1st Deriv wrt r: diff(f,r).subs(a2*r**2+a3*r**3+a4*r**4,ser).subs(g/(-L)**c+a0*c/L,fac).subs(2*a2*r+3*a3*r**2+4*a4*r**3,dser)
2nd Deriv wrt r: simplify(diff(f,r,2).subs(a2*r**2+a3*r**3+a4*r**4,ser).subs(g/(-L)**c+a0*c/L,fac).subs(2*a2*r+3*a3*r**2+4*a4*r**3,dser).subs(2*a2+6*a3*r+12*a4*r**2,d2ser))
3rd Deriv wrt r:  simplify(diff(f,r,3).subs(a2*r**2+a3*r**3+a4*r**4,ser).subs(g/(-L)**c+a0*c/L,fac).subs(2*a2*r+3*a3*r**2+4*a4*r**3,dser).subs(2*a2+6*a3*r+12*a4*r**2,d2ser).subs(6*a3+24*a4*r,d3ser))

1st Deriv wrt a0: diff(f,a0)
1st Deriv wrt a0, followed by deriv wrt r: simplify(diff(diff(f,a0),r)).subs(r-L,rml)
1st Deriv wrt a0, followed by 2nd deriv wrt 2: simplify(diff(diff(f,a0),r,2)).subs(r-L,rml)

1st Deriv wrt an: diff(f,an).subs(r-L,rml) --> r^m*rml**c
1st Deriv wrt an, followed by deriv wrt r: simplify(diff(diff(f,an),r).subs(r-L,rml)) --> r^n*rml^(c-1)*(c*r+n*rml)
1st Deriv wrt an, followed by 2nd deriv wrt r: simplify(diff(diff(f,an),r,2).subs(r-L,rml)) --> r^(n-2)*rml^(c-2)*(c*r**2*(c-1) + 2*n*c*r*rml + n(n-1)*rml^2)