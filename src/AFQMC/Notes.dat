
-- Keeping H1 in host memory in HamOps and Propagator

-- make sure you can initialize arrays (by copy or move) from arrays using different allocators.
   Then you can decide to initialize arrays in host memory in factories and the constructor
   takes care of initializing the object's array in the appropriate memory space during construction!

-- when more of the cuda code is complete, guard cpu only code with ifndef QMC_CUDA


-- right now the use of csr_matrix in cuda code is unsafe and generally difficult.
   To solve this, make a new csr_matrix-like class that looks like csr_matrix but that doesn't
   allow mutation/modification. This allows you to store things like nnz directly, since this class
   can't add/remove elements. Then pass nnz through the dispatching of csrmm and csrmv. This class 
   is memory owning. 

-- There is something strange with cuda's RNG. Not sure if this is a bug or a problem with my use.
   Right now I'm using QMCPACK's RNG on the host and copying the values to the device.

-- add equilibration to the estimators. It can be read in the executoion block and pass to all estimators and each estimator can redefine it inside their block. Then estimators simply don't execute if within equilibration time.


- Remember to add missing overloads for shm_ptr_raw_ptr_dispatch to iterator based copy in boost::multi.
